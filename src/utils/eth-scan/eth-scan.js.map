{"version":3,"sources":["../../src/eth-scan.ts"],"names":["encode","callSingle","toBalanceMap","toNestedBalanceMap","BALANCE_OF_ID","BALANCE_OF_TYPE","ETHER_BALANCES_ID","ETHER_BALANCES_TYPE","TOKEN_BALANCES_ID","TOKEN_BALANCES_TYPE","TOKENS_BALANCE_ID","TOKENS_BALANCE_TYPE","withId","getEtherBalances","provider","addresses","options","results","batch","getTokenBalances","tokenAddress","address","getTokensBalances","tokenAddresses","balances","Promise","all","map","Object","values","getTokensBalance"],"mappings":"AAAA,OAASA,MAAT,KAAuB,cAAvB,CACA,OAASC,UAAT,CAAqBC,YAArB,CAAmCC,kBAAnC,KAA6D,OAA7D,CACA,OACEC,aADF,CAEEC,eAFF,CAGEC,iBAHF,CAIEC,mBAJF,CAKEC,iBALF,CAMEC,mBANF,CAOEC,iBAPF,CAQEC,mBARF,KASO,aATP,CAYA,OAASC,MAAT,KAAuB,SAAvB,CAEA;;;;;;;GAQA,MAAO,MAAMC,CAAAA,gBAAgB,CAAG,MAC9BC,CAD8B,CAE9BC,CAF8B,CAG9BC,CAH8B,GAIN,CACxB,KAAMC,CAAAA,CAAO,CAAG,KAAMhB,CAAAA,UAAU,CAC9Ba,CAD8B,CAE9BC,CAF8B,CAG9B,EAH8B,CAI9B,EAJ8B,CAK7BG,CAAD,EAAWN,MAAM,CAACN,iBAAD,CAAoBN,MAAM,CAACO,mBAAD,CAAsB,CAACW,CAAD,CAAtB,CAA1B,CALa,CAM9B,IAAM,EANwB,CAO9BF,CAP8B,CAAhC,CAUA,MAAOd,CAAAA,YAAY,CAACa,CAAD,CAAYE,CAAZ,CACpB,CAhBM,CAkBP;;;;;;;;;GAUA,MAAO,MAAME,CAAAA,gBAAgB,CAAG,MAC9BL,CAD8B,CAE9BC,CAF8B,CAG9BK,CAH8B,CAI9BJ,CAJ8B,GAKN,CACxB,KAAMC,CAAAA,CAAO,CAAG,KAAMhB,CAAAA,UAAU,CAC9Ba,CAD8B,CAE9BC,CAF8B,CAG9BA,CAH8B,CAI9BK,CAJ8B,CAK7BF,CAAD,EAAWN,MAAM,CAACJ,iBAAD,CAAoBR,MAAM,CAACS,mBAAD,CAAsB,CAACS,CAAD,CAAQE,CAAR,CAAtB,CAA1B,CALa,CAM7BC,CAAD,EAAaT,MAAM,CAACR,aAAD,CAAgBJ,MAAM,CAACK,eAAD,CAAkB,CAACgB,CAAD,CAAlB,CAAtB,CANW,CAO9BL,CAP8B,CAAhC,CAUA,MAAOd,CAAAA,YAAY,CAACa,CAAD,CAAYE,CAAZ,CACpB,CAjBM,CAmBP;;;;;;;;GASA,MAAO,MAAMK,CAAAA,iBAAiB,CAAG,MAC/BR,CAD+B,CAE/BC,CAF+B,CAG/BQ,CAH+B,CAI/BP,CAJ+B,GAKK,CACpC,KAAMQ,CAAAA,CAAQ,CAAG,KAAMC,CAAAA,OAAO,CAACC,GAAR,CACrBX,CAAS,CAACY,GAAV,CAAc,KAAON,CAAAA,CAAP,EAAmBO,MAAM,CAACC,MAAP,CAAc,KAAMC,CAAAA,gBAAgB,CAAChB,CAAD,CAAWO,CAAX,CAAoBE,CAApB,CAAoCP,CAApC,CAApC,CAAjC,CADqB,CAAvB,CAIA,MAAOb,CAAAA,kBAAkB,CAACY,CAAD,CAAYQ,CAAZ,CAA4BC,CAA5B,CAC1B,CAXM,CAaP;;;;;;;;;GAUA,MAAO,MAAMM,CAAAA,gBAAgB,CAAG,MAC9BhB,CAD8B,CAE9BO,CAF8B,CAG9BE,CAH8B,CAI9BP,CAJ8B,GAKN,CACxB,KAAMC,CAAAA,CAAO,CAAG,KAAMhB,CAAAA,UAAU,CAC9Ba,CAD8B,CAE9BS,CAF8B,CAG9BF,CAH8B,CAI9BE,CAJ8B,CAK7BL,CAAD,EAAWN,MAAM,CAACF,iBAAD,CAAoBV,MAAM,CAACW,mBAAD,CAAsB,CAACU,CAAD,CAAUH,CAAV,CAAtB,CAA1B,CALa,CAM9B,IAAMN,MAAM,CAACR,aAAD,CAAgBJ,MAAM,CAACK,eAAD,CAAkB,CAACgB,CAAD,CAAlB,CAAtB,CANkB,CAO9BL,CAP8B,CAAhC,CAUA,MAAOd,CAAAA,YAAY,CAACqB,CAAD,CAAiBN,CAAjB,CACpB,CAjBM","sourcesContent":["import { encode } from '@findeth/abi';\nimport { callSingle, toBalanceMap, toNestedBalanceMap } from './api';\nimport {\n  BALANCE_OF_ID,\n  BALANCE_OF_TYPE,\n  ETHER_BALANCES_ID,\n  ETHER_BALANCES_TYPE,\n  TOKEN_BALANCES_ID,\n  TOKEN_BALANCES_TYPE,\n  TOKENS_BALANCE_ID,\n  TOKENS_BALANCE_TYPE\n} from './constants';\nimport { ProviderLike } from './providers';\nimport type { BalanceMap, EthScanOptions } from './types';\nimport { withId } from './utils';\n\n/**\n * Get the Ether balances for the addresses specified.\n *\n * @param {ProviderLike} provider\n * @param {string[]} addresses\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap>}\n */\nexport const getEtherBalances = async (\n  provider: ProviderLike,\n  addresses: string[],\n  options?: EthScanOptions\n): Promise<BalanceMap> => {\n  const results = await callSingle(\n    provider,\n    addresses,\n    [],\n    [],\n    (batch) => withId(ETHER_BALANCES_ID, encode(ETHER_BALANCES_TYPE, [batch])),\n    () => '',\n    options\n  );\n\n  return toBalanceMap(addresses, results);\n};\n\n/**\n * Get the ERC-20 token balances of the token with the address `tokenAddress` for the addresses\n * specified.\n *\n * @param {ProviderLike} provider\n * @param {string[]} addresses\n * @param {string} tokenAddress\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap>}\n */\nexport const getTokenBalances = async (\n  provider: ProviderLike,\n  addresses: string[],\n  tokenAddress: string,\n  options?: EthScanOptions\n): Promise<BalanceMap> => {\n  const results = await callSingle(\n    provider,\n    addresses,\n    addresses,\n    tokenAddress,\n    (batch) => withId(TOKEN_BALANCES_ID, encode(TOKEN_BALANCES_TYPE, [batch, tokenAddress])),\n    (address) => withId(BALANCE_OF_ID, encode(BALANCE_OF_TYPE, [address])),\n    options\n  );\n\n  return toBalanceMap(addresses, results);\n};\n\n/**\n * Get the ERC-20 token balances for multiple contracts, for multiple addresses.\n *\n * @param {ProviderLike} provider\n * @param {string[]} addresses\n * @param {string[]} tokenAddresses\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap<BalanceMap>>}\n */\nexport const getTokensBalances = async (\n  provider: ProviderLike,\n  addresses: string[],\n  tokenAddresses: string[],\n  options?: EthScanOptions\n): Promise<BalanceMap<BalanceMap>> => {\n  const balances = await Promise.all(\n    addresses.map(async (address) => Object.values(await getTokensBalance(provider, address, tokenAddresses, options)))\n  );\n\n  return toNestedBalanceMap(addresses, tokenAddresses, balances);\n};\n\n/**\n * Get the ERC-20 token balance of the tokens with the addresses `tokenAddresses` for the single\n * address specified.\n *\n * @param {ProviderLike} provider\n * @param {string} address\n * @param {string[]} tokenAddresses\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap>}\n */\nexport const getTokensBalance = async (\n  provider: ProviderLike,\n  address: string,\n  tokenAddresses: string[],\n  options?: EthScanOptions\n): Promise<BalanceMap> => {\n  const results = await callSingle(\n    provider,\n    tokenAddresses,\n    address,\n    tokenAddresses,\n    (batch) => withId(TOKENS_BALANCE_ID, encode(TOKENS_BALANCE_TYPE, [address, batch])),\n    () => withId(BALANCE_OF_ID, encode(BALANCE_OF_TYPE, [address])),\n    options\n  );\n\n  return toBalanceMap(tokenAddresses, results);\n};\n"],"file":"eth-scan.js"}