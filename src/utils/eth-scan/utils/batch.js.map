{"version":3,"sources":["../../../src/utils/batch.ts"],"names":["chunk","input","size","reduce","array","item","index","slice","batch","handler","addresses","chunks","current","next","Promise","resolve"],"mappings":"AAEA;;;;;;;GAQA,MAAO,MAAMA,CAAAA,KAAK,CAAG,CAAIC,CAAJ,CAAgBC,CAAhB,GACZD,CAAK,CAACE,MAAN,CAAoB,CAACC,CAAD,CAAQC,CAAR,CAAcC,CAAd,GACD,CAAjB,EAAAA,CAAK,CAAGJ,CAAR,CAAqB,CAAC,GAAGE,CAAJ,CAAW,CAACC,CAAD,CAAX,CAArB,CAA0C,CAAC,GAAGD,CAAK,CAACG,KAAN,CAAY,CAAZ,CAAe,CAAC,CAAhB,CAAJ,CAAwB,CAAC,GAAGH,CAAK,CAACG,KAAN,CAAY,CAAC,CAAb,EAAgB,CAAhB,CAAJ,CAAwBF,CAAxB,CAAxB,CAD5C,CAEJ,EAFI,CADF,CAMP;;;;;;;;GASA,MAAO,MAAMG,CAAAA,KAAK,CAAG,MACnBC,CADmB,CAEnBP,CAFmB,CAGnBQ,CAHmB,GAIF,CACjB,KAAMC,CAAAA,CAAM,CAAGX,KAAK,CAACU,CAAD,CAAYR,CAAZ,CAApB,CAEA,MAAOS,CAAAA,CAAM,CAACR,MAAP,CAA4B,MAAOS,CAAP,CAAgBC,CAAhB,GAC1BC,OAAO,CAACC,OAAR,CAAgB,CAAC,IAAI,KAAMH,CAAAA,CAAV,CAAD,CAAqB,IAAI,KAAMH,CAAAA,CAAO,CAACI,CAAD,CAAjB,CAArB,CAAhB,CADF,CAEJC,OAAO,CAACC,OAAR,CAAqB,EAArB,CAFI,CAGR,CAVM","sourcesContent":["import { Result } from '../types';\n\n/**\n * Split an array per `size` items.\n *\n * @param {T[]} input\n * @param {number} size\n * @return {T[][]} An array of arrays of the specified type.\n * @template T\n */\nexport const chunk = <T>(input: T[], size: number): T[][] => {\n  return input.reduce<T[][]>((array, item, index) => {\n    return index % size === 0 ? [...array, [item]] : [...array.slice(0, -1), [...array.slice(-1)[0], item]];\n  }, []);\n};\n\n/**\n * Batch the function calls to `handler` per `size` items.\n *\n * @param {(addresses: string[]) => Promise<T[]>} handler A function that takes a batch of addresses and returns the balance for the addresses.\n * @param {number} size The size of the batches.\n * @param {string[]} addresses The addresses to batch.\n * @return {Promise<T[]>} A promise with the balances.\n * @template T\n */\nexport const batch = async <T = Result>(\n  handler: (addresses: string[]) => Promise<T[]>,\n  size: number,\n  addresses: string[]\n): Promise<T[]> => {\n  const chunks = chunk(addresses, size);\n\n  return chunks.reduce<Promise<T[]>>(async (current, next) => {\n    return Promise.resolve([...(await current), ...(await handler(next))]);\n  }, Promise.resolve<T[]>([]));\n};\n"],"file":"batch.js"}