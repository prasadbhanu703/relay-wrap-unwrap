import{decode,encode,fromHex,toHex}from"@findeth/abi";import{ethers,waffle}from"hardhat";import{ETHER_BALANCES_ID,ETHER_BALANCES_TYPE,TOKEN_BALANCES_ID,TOKEN_BALANCES_TYPE}from"../constants";import{fixture}from"../eth-scan.test";import{withId}from"../utils";import EthersProvider from"./ethers";const{createFixtureLoader,provider}=waffle,{isProvider,send}=EthersProvider,loadFixture=createFixtureLoader(provider.getWallets(),provider);describe("isProvider",()=>{it("checks if a provider is an Ethers.js provider",()=>{expect(isProvider(ethers.provider)).toBe(!0),expect(isProvider({})).toBe(!1)})}),describe("send",()=>{it("gets the Ether balances from the contract",async()=>{const{contract:a,addresses:b}=await loadFixture(fixture),c=withId(ETHER_BALANCES_ID,encode(ETHER_BALANCES_TYPE,[b])),d=await send(ethers.provider,"eth_call",[{to:a.address,data:c}]),e=decode(["(bool,bytes)[]"],fromHex(d))[0];for(let a=0;a<b.length;a++){const c=await ethers.provider.getBalance(b[a]),[d,f]=e[a];expect(d).toBe(!0),expect(toHex(f)).toBe(c.toHexString().slice(2).padStart(64,"0"))}}),it("gets the token balances from the contract",async()=>{const{contract:a,addresses:b,token:c}=await loadFixture(fixture);await c.mock.balanceOf.returns("1000");const d=withId(TOKEN_BALANCES_ID,encode(TOKEN_BALANCES_TYPE,[b,c.address])),e=await send(ethers.provider,"eth_call",[{to:a.address,data:d}]),f=decode(["(bool,bytes)[]"],fromHex(e))[0];for(let a=0;a<b.length;a++){const[b,c]=f[a];expect(b).toBe(!0),expect(toHex(c)).toBe("00000000000000000000000000000000000000000000000000000000000003e8")}})});
//# sourceMappingURL=ethers.test.js.map