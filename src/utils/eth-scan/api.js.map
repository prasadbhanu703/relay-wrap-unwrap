{"version":3,"sources":["../../src/api.ts"],"names":["decode","toNumber","BATCH_SIZE","CONTRACT_ADDRESS","call","batch","isResult","result","Array","isArray","length","toBalanceMap","addresses","results","reduce","current","next","index","value","slice","toNestedBalanceMap","tokenAddresses","callSingle","provider","batchAddresses","contractAddresses","encodeData","encodeSingle","options","contractAddress","batchSize","batchedAddresses","data","buffer","retryCalls","contracts","Promise","all","map","address","newResult"],"mappings":"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","sourcesContent":["import { decode, toNumber } from '@findeth/abi';\nimport { BATCH_SIZE, CONTRACT_ADDRESS } from './constants';\nimport { call, ProviderLike } from './providers';\nimport { BalanceMap, EthScanOptions, Result } from './types';\nimport { batch } from './utils';\n\nconst isResult = (result: unknown): result is Result => {\n  return Array.isArray(result) && result.length === 2;\n};\n\n/**\n * Get a balance map from an array of addresses and an array of balances.\n *\n * @param {string[]} addresses\n * @param {bigint[]} results\n * @return {BalanceMap}\n */\nexport const toBalanceMap = (addresses: string[], results: Array<bigint | Result>): BalanceMap => {\n  return results.reduce<BalanceMap>((current, next, index) => {\n    const value = isResult(next) ? toNumber(next[1].slice(0, 32)) : next;\n\n    return {\n      ...current,\n      [addresses[index]]: value\n    };\n  }, {});\n};\n\n/**\n * Get a nested balance map from an array of addresses, token addresses, and results.\n *\n * @param {string[]} addresses\n * @param {bigint[]} tokenAddresses\n * @param {BalanceMap<BalanceMap>} results\n */\nexport const toNestedBalanceMap = (\n  addresses: string[],\n  tokenAddresses: string[],\n  results: Array<Array<bigint | Result>>\n): BalanceMap<BalanceMap> => {\n  return results.reduce<BalanceMap<BalanceMap>>((current, next, index) => {\n    return {\n      ...current,\n      [addresses[index]]: toBalanceMap(tokenAddresses, next)\n    };\n  }, {});\n};\n\n/**\n * Low level API function to send a contract call that returns a single Result array. It will automatically retry any\n * failed calls.\n *\n * @param provider\n * @param batchAddresses The addresses to batch by\n * @param addresses The address(es) to use when retrying failed calls\n * @param contractAddresses The contract address(es) to use when retrying failed calls\n * @param encodeData\n * @param encodeSingle\n * @param options\n */\nexport const callSingle = async (\n  provider: ProviderLike,\n  batchAddresses: string[],\n  addresses: string | string[],\n  contractAddresses: string | string[],\n  encodeData: (addresses: string[]) => string,\n  encodeSingle: (address: string) => string,\n  options?: EthScanOptions\n): Promise<Result[]> => {\n  const contractAddress = options?.contractAddress ?? CONTRACT_ADDRESS;\n  const batchSize = options?.batchSize ?? BATCH_SIZE;\n\n  const results = await batch(\n    async (batchedAddresses: string[]) => {\n      const data = encodeData(batchedAddresses);\n      const buffer = await call(provider, contractAddress, data);\n\n      return decode(['(bool,bytes)[]'], buffer)[0] as Result[];\n    },\n    batchSize,\n    batchAddresses\n  );\n\n  return retryCalls(provider, addresses, contractAddresses, results, encodeSingle);\n};\n\n/**\n * Retry calls to the contract directly, if a contract call in the eth-scan contract failed.\n *\n * @param provider\n * @param addresses\n * @param contracts\n * @param results\n * @param encodeData\n */\nexport const retryCalls = async (\n  provider: ProviderLike,\n  addresses: string | string[],\n  contracts: string | string[],\n  results: Result[],\n  encodeData: (address: string) => string\n): Promise<Result[]> => {\n  return Promise.all(\n    results.map(async (result, index) => {\n      if (result[0]) {\n        return result;\n      }\n\n      const address = typeof addresses === 'string' ? addresses : addresses[index];\n      const contractAddress = typeof contracts === 'string' ? contracts : contracts[index];\n      const data = encodeData(address);\n\n      try {\n        const newResult = await call(provider, contractAddress, data);\n        return [true, newResult] as [boolean, Uint8Array];\n      } catch {\n        // noop\n      }\n\n      return result;\n    })\n  );\n};\n"],"file":"api.js"}